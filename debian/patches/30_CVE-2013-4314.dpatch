#! /bin/sh /usr/share/dpatch/dpatch-run
## 30_CVE-2013-4314.dpatch by Salvatore Bonaccorso <carnil@debian.org>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Fix hostname check bypassing vulnerability
## DP: Fix handling of NULL bytes inside subjectAltName general names when
## DP: formatting an X509 extension as a string.
## DP: .
## DP: When a CA than an SSL client trusts issues a server certificate that
## DP: has a null byte in the subjectAltName, remote attackers can obtain a
## DP: certifcate for 'www.foo.org\0.example.com' from the CA to spoof
## DP: 'www.foo.org' and conduct man-in-the-middle attacks between the
## DP: pyOpenSSL-using client and SSL servers.
## DP: Origin: upstream, http://bazaar.launchpad.net/~exarkun/pyopenssl/trunk/revision/169
## DP: Bug-Debian: http://bugs.debian.org/722055
## DP: Bug-RedHat: https://bugzilla.redhat.com/show_bug.cgi?id=1005325

@DPATCH@
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' pyopenssl~/src/crypto/x509ext.c pyopenssl/src/crypto/x509ext.c
--- pyopenssl~/src/crypto/x509ext.c	2013-09-20 15:31:05.000000000 +0200
+++ pyopenssl/src/crypto/x509ext.c	2013-09-21 17:54:11.475780655 +0200
@@ -227,6 +227,75 @@
     return Py_FindMethod(crypto_X509Extension_methods, (PyObject *)self, name);
 }
 
+
+/* Special handling of subjectAltName.  OpenSSL's builtin formatter,
+ * X509V3_EXT_print, mishandles NUL bytes allowing a truncated display that
+ * does not accurately reflect what's in the extension.
+ */
+int
+crypto_X509Extension_str_subjectAltName(crypto_X509ExtensionObj *self, BIO *bio) {
+    GENERAL_NAMES *names;
+    const X509V3_EXT_METHOD *method = NULL;
+    long i, length, num;
+    const unsigned char *p;
+
+    method = X509V3_EXT_get(self->x509_extension);
+    if (method == NULL) {
+        return -1;
+    }
+
+    p = self->x509_extension->value->data;
+    length = self->x509_extension->value->length;
+    if (method->it) {
+        names = (GENERAL_NAMES*)(ASN1_item_d2i(NULL, &p, length,
+                                               ASN1_ITEM_ptr(method->it)));
+    } else {
+        names = (GENERAL_NAMES*)(method->d2i(NULL, &p, length));
+    }
+    if (names == NULL) {
+        return -1;
+    }
+
+    num = sk_GENERAL_NAME_num(names);
+    for (i = 0; i < num; i++) {
+        GENERAL_NAME *name;
+        ASN1_STRING *as;
+        name = sk_GENERAL_NAME_value(names, i);
+        switch (name->type) {
+            case GEN_EMAIL:
+                BIO_puts(bio, "email:");
+                as = name->d.rfc822Name;
+                BIO_write(bio, ASN1_STRING_data(as),
+                          ASN1_STRING_length(as));
+                break;
+            case GEN_DNS:
+                BIO_puts(bio, "DNS:");
+                as = name->d.dNSName;
+                BIO_write(bio, ASN1_STRING_data(as),
+                          ASN1_STRING_length(as));
+                break;
+            case GEN_URI:
+                BIO_puts(bio, "URI:");
+                as = name->d.uniformResourceIdentifier;
+                BIO_write(bio, ASN1_STRING_data(as),
+                          ASN1_STRING_length(as));
+                break;
+            default:
+                /* use builtin print for GEN_OTHERNAME, GEN_X400,
+                 * GEN_EDIPARTY, GEN_DIRNAME, GEN_IPADD and GEN_RID
+                 */
+                GENERAL_NAME_print(bio, name);
+        }
+        /* trailing ', ' except for last element */
+        if (i < (num - 1)) {
+            BIO_puts(bio, ", ");
+        }
+    }
+    sk_GENERAL_NAME_pop_free(names, GENERAL_NAME_free);
+
+    return 0;
+}
+
 /*
  * Print a nice text representation of the certificate request.
  */
@@ -238,7 +307,13 @@
     PyObject *str;
     BIO *bio = BIO_new(BIO_s_mem());
 
-    if (!X509V3_EXT_print(bio, self->x509_extension, 0, 0))
+    if (OBJ_obj2nid(self->x509_extension->object) == NID_subject_alt_name) {
+            if (crypto_X509Extension_str_subjectAltName(self, bio) == -1) {
+                    BIO_free(bio);
+                    exception_from_error_queue(crypto_Error);
+                    return NULL;
+            }
+    } else if (!X509V3_EXT_print(bio, self->x509_extension, 0, 0))
     {
         BIO_free(bio);
         exception_from_error_queue(crypto_Error);
